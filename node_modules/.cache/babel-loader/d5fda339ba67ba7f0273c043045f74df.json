{"ast":null,"code":"export class SudokuSolver {\n  constructor(board) {\n    this.mem = board;\n  }\n\n  findNextEmpty() {\n    for (let i = 0; i < this.mem[0].length; i++) {\n      for (let j = 0; j < this.mem[0].length; j++) {\n        if (this.mem[i][j] == 0) {\n          return [i, j];\n        }\n\n        ;\n      }\n\n      ;\n    }\n\n    ;\n  }\n\n  checkNumInRow(num, row) {\n    for (let j = 0; j < this.mem[0].length; j++) {\n      if (this.mem[row][j] == num) {\n        return true;\n      }\n\n      ;\n    }\n\n    ;\n    return false;\n  }\n\n  checkNumInColumn(num, column) {\n    for (let i = 0; i < this.mem[0].length; i++) {\n      if (this.mem[i][column] == num) {\n        return true;\n      }\n\n      ;\n    }\n\n    ;\n    return false;\n  }\n\n  checkNumInSquare(num, row, column) {\n    let startRow = 0;\n    let startCol = 0; //In which 3x3 square is the number located?\n\n    if (row > 5) {\n      startRow = 6;\n    } else if (row > 2) {\n      startRow = 3;\n    }\n\n    ;\n\n    if (column > 5) {\n      startCol = 6;\n    } else if (column > 2) {\n      startCol = 3;\n    }\n\n    ; //Iterate over the square.\n\n    for (let i = startRow; i < startRow + 3; i++) {\n      for (let j = startCol; j < startCol + 3; j++) {\n        if (this.mem[i][j] == num) {\n          return true;\n        }\n\n        ;\n      }\n\n      ;\n    }\n\n    ;\n    return false;\n  }\n\n  checkForDuplicates(num) {\n    //If there are two of the same numbers in the same row, column or square the algorithm will be stuck in an\n    //infinite loop.\n    let countRow = 0;\n    let countCol = 0;\n    let countSquare = 0; //Check the rows.\n\n    for (let i = 0; i < this.mem.length; i++) {\n      countRow = 0;\n\n      for (let j = 0; j < this.mem.length; j++) {\n        if (this.mem[i][j] === num) {\n          countRow++;\n\n          if (countRow > 1) {\n            return true;\n          }\n        }\n\n        ;\n      }\n\n      ;\n    }\n\n    ; //Check the columns\n\n    for (let j = 0; j < this.mem.length; j++) {\n      countCol = 0;\n\n      for (let i = 0; i < this.mem.length; i++) {\n        if (this.mem[i][j] === num) {\n          countCol++;\n\n          if (countCol > 1) {\n            return true;\n          }\n        }\n\n        ;\n      }\n\n      ;\n    }\n\n    ; //Check the 9 squares\n\n    for (let squareI = 0; squareI < this.mem.length; squareI += 3) {\n      for (let squareJ = 0; squareJ < this.mem.length; squareJ += 3) {\n        countSquare = 0;\n\n        for (let i = squareI; i < squareI + 3; i++) {\n          for (let j = squareJ; j < squareJ + 3; j++) {\n            if (this.mem[i][j] === num) {\n              countSquare++;\n\n              if (countSquare > 1) {\n                return true;\n              }\n            }\n\n            ;\n          }\n\n          ;\n        }\n\n        ;\n      }\n\n      ;\n    }\n\n    ;\n    return false;\n  }\n\n  solve() {\n    //Check to see if there is no two of the same number in the same row, column and square.\n    for (let number = 1; number < 10; number++) {\n      if (this.checkForDuplicates(number)) {\n        return \"Unsolvable.\";\n      }\n    } //This will solve the sudoku puzzle using the backtracking algorithm.\n\n\n    this.log = [];\n    this.count = 1;\n    let next;\n    let row;\n    let col; //while there are empty cells on the matrix.\n\n    while (this.findNextEmpty()) {\n      //if all the numbers have been tested on the next empty cell, there is a problem.\n      //if there has been a problem on the previous attempt, push the last try from the log and work it again.\n      if (this.count > 9) {\n        next = this.log.pop(); //If the log is empty, then we tried all the possible combinations, the puzzle is unsolvable.\n\n        if (next) {\n          row = next[0];\n          col = next[1];\n          this.mem[row][col] = 0;\n          this.count = next[2];\n          this.count++;\n        } else {\n          return \"Unsolvable.\";\n        }\n      } else {\n        next = this.findNextEmpty();\n        row = next[0];\n        col = next[1];\n      }\n\n      ; //try until 9 to fit the counter in the empty cell, if it is a correct fit log the number and the cells.\n\n      while (this.count < 10) {\n        if (!this.checkNumInRow(this.count, row)) {\n          if (!this.checkNumInColumn(this.count, col)) {\n            if (!this.checkNumInSquare(this.count, row, col)) {\n              this.log.push([row, col, this.count]);\n              this.mem[row][col] = this.count;\n              this.count = 1;\n              break;\n            }\n          }\n        }\n\n        this.count++;\n      }\n\n      ;\n    }\n\n    ;\n    let answer = [...this.mem];\n    return answer;\n  }\n\n}\n;\nexport { SudokuSolver as default }; //Some sample solvable boards to use with the React app.\n\n/*\nlet board1 = [\n    [0, 0, 3, 0, 5, 8, 0, 0, 9],\n    [0, 0, 9, 7, 4, 0, 0, 6, 2],\n    [0, 0, 0, 2, 0, 0, 5, 3, 8],\n    [4, 0, 2, 0, 0, 0, 0, 1, 3],\n    [9, 0, 0, 3, 0, 4, 0, 8, 7],\n    [6, 0, 8, 0, 7, 0, 2, 5, 0],\n    [3, 0, 0, 0, 0, 5, 0, 2, 0],\n    [0, 0, 5, 0, 3, 7, 0, 9, 0],\n    [0, 1, 7, 0, 0, 0, 3, 4, 0]\n];\n\n\nlet board2 = [\n    [0, 5, 1, 3, 6, 2, 7, 0, 0],\n    [0, 4, 0, 0, 5, 8, 0, 0, 0],\n    [0, 0, 0, 4, 0, 0, 0, 2, 5],\n    [0, 8, 0, 0, 0, 0, 9, 0, 3],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [7, 0, 5, 0, 0, 0, 0, 8, 0],\n    [1, 2, 0, 0, 0, 9, 0, 0, 0],\n    [0, 0, 0, 2, 8, 0, 0, 6, 0],\n    [0, 0, 8, 5, 3, 4, 2, 9, 0]\n];\n\n\nlet board3 = [\n    [0, 2, 0, 0, 0, 4, 3, 0, 0],\n    [9, 0, 0, 0, 2, 0, 0, 0, 8],\n    [0, 0, 0, 6, 0, 9, 0, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [0, 7, 2, 5, 0, 3, 6, 8, 0],\n    [6, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 0, 2, 0, 5, 0, 0, 0],\n    [1, 0, 0, 0, 9, 0, 0, 0, 3],\n    [0, 0, 9, 8, 0, 0, 0, 6, 0]\n]\n\nlet board4 = [\n    [0, 2, 0, 0, 0, 4, 3, 0, 0],\n    [0, 0, 0, 0, 2, 0, 0, 0, 0],\n    [0, 0, 0, 6, 0, 0, 0, 5, 0],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 7, 0, 5, 0, 0, 6, 0, 0],\n    [6, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 0, 2, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 9, 0, 0, 0, 3],\n    [0, 0, 9, 8, 0, 0, 0, 6, 0]\n]\n*/\n//-------------------------------------------For testing purposes--------------------------------------------------\n//let solver0 = new SudokuSolver(board0);\n//console.log(\"Solving 0\");\n//console.log(solver0.solve());\n\n/*\nsolver1 = new SudokuSolver(board1);\nsolver2 = new SudokuSolver(board2);\nsolver3 = new SudokuSolver(board3);\nsolver4 = new SudokuSolver(board4);\nconsole.log(\"Solving 1\");\nconsole.log(solver1.solve());\nconsole.log(\"Solving 2\");\nconsole.log(solver2.solve());\nconsole.log(\"Solving 3\");\nconsole.log(solver3.solve());\nconsole.log(\"Solving 4\");\nconsole.log(solver4.solve());\n*/","map":{"version":3,"sources":["/home/lfbianchi/GitHub/javascriptWs/sudokusolver/my-app/src/sudokusolver.js"],"names":["SudokuSolver","constructor","board","mem","findNextEmpty","i","length","j","checkNumInRow","num","row","checkNumInColumn","column","checkNumInSquare","startRow","startCol","checkForDuplicates","countRow","countCol","countSquare","squareI","squareJ","solve","number","log","count","next","col","pop","push","answer","default"],"mappings":"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","sourcesContent":["export class SudokuSolver {\n\n    constructor(board) {\n        this.mem = board;\n    };\n\n    findNextEmpty() {\n        for (let i = 0; i < this.mem[0].length; i++) {\n            for (let j = 0; j < this.mem[0].length; j++) {\n                if (this.mem[i][j] == 0) {\n                    return [i, j];\n                };\n            };\n        };\n    };\n\n    checkNumInRow(num, row) {\n        for (let j = 0; j < this.mem[0].length; j++) {\n            if (this.mem[row][j] == num) {\n                return true;\n            };\n        };\n        return false;\n    };\n\n    checkNumInColumn(num, column) {\n        for (let i = 0; i < this.mem[0].length; i++) {\n            if (this.mem[i][column] == num) {\n                return true;\n            };\n        };\n        return false;\n    };\n\n    checkNumInSquare(num, row, column) {\n        let startRow = 0;\n        let startCol = 0;\n        //In which 3x3 square is the number located?\n        if (row > 5) {startRow = 6}\n        else if (row > 2) {startRow = 3};\n\n        if (column > 5) {startCol = 6}\n        else if (column > 2) {startCol = 3};\n\n        //Iterate over the square.\n        for (let i = startRow; i < startRow + 3; i++) {\n            for (let j = startCol; j < startCol + 3; j++) {\n                if (this.mem[i][j] == num) {\n                    return true;\n                };\n            };\n        };\n        return false;\n    };\n\n    checkForDuplicates(num) {\n        //If there are two of the same numbers in the same row, column or square the algorithm will be stuck in an\n        //infinite loop.\n        let countRow = 0;\n        let countCol = 0;\n        let countSquare = 0;\n\n        //Check the rows.\n        for (let i = 0; i < this.mem.length; i++) {\n            countRow = 0;\n            for (let j = 0; j < this.mem.length; j++) {\n                if(this.mem[i][j] === num){\n                    countRow++;\n                    if (countRow > 1) { return true }\n                };\n            };\n        };\n\n        //Check the columns\n        for (let j = 0; j < this.mem.length; j++) {\n            countCol = 0;\n            for (let i = 0; i < this.mem.length; i++) {\n                if (this.mem[i][j] === num) {\n                    countCol++;\n                    if (countCol > 1) { return true;}\n                };\n            };\n        };\n\n        //Check the 9 squares\n        for (let squareI = 0; squareI < this.mem.length; squareI += 3) {\n            for (let squareJ = 0; squareJ < this.mem.length; squareJ += 3) {\n                countSquare = 0;\n                for (let i = squareI; i < squareI + 3; i++) {\n                    for (let j = squareJ; j < squareJ + 3; j++) {\n                        if (this.mem[i][j] === num) {\n                            countSquare++;\n                            if(countSquare > 1) {return true}\n                        };\n                    };\n                };\n            };\n        };\n\n        return false;\n    };\n\n    solve() {\n        //Check to see if there is no two of the same number in the same row, column and square.\n        for (let number = 1; number< 10; number++) {\n            if (this.checkForDuplicates(number)) {\n                return \"Unsolvable.\";\n            }\n        }\n\n        //This will solve the sudoku puzzle using the backtracking algorithm.\n        this.log = [];\n        this.count = 1;\n\n        let next;\n        let row;\n        let col;\n\n        //while there are empty cells on the matrix.\n        while(this.findNextEmpty()) {\n            //if all the numbers have been tested on the next empty cell, there is a problem.\n            //if there has been a problem on the previous attempt, push the last try from the log and work it again.\n            if (this.count > 9) {\n                next = this.log.pop();\n\n                //If the log is empty, then we tried all the possible combinations, the puzzle is unsolvable.\n                if (next) {\n                    row = next[0];\n                    col = next[1];\n                    this.mem[row][col] = 0;\n                    this.count = next[2];\n                    this.count++;\n\n                } else {\n                    return \"Unsolvable.\";\n                }\n\n            } else {\n                next = this.findNextEmpty();\n                row = next[0];\n                col = next[1];\n            };\n\n\n\n            //try until 9 to fit the counter in the empty cell, if it is a correct fit log the number and the cells.\n            while (this.count < 10) {\n                if (!this.checkNumInRow(this.count, row)){\n                    if (!this.checkNumInColumn(this.count, col)) {\n                        if (!this.checkNumInSquare(this.count, row, col)) {\n                            this.log.push([row, col, this.count]);\n                            this.mem[row][col] = this.count;\n                            this.count = 1;\n                            break;\n                        }\n                    }\n                }\n                this.count++;\n            };\n        };\n\n        let answer = [...this.mem];\n        return answer;\n    };\n\n};\n\nexport { SudokuSolver as default};\n\n//Some sample solvable boards to use with the React app.\n/*\nlet board1 = [\n    [0, 0, 3, 0, 5, 8, 0, 0, 9],\n    [0, 0, 9, 7, 4, 0, 0, 6, 2],\n    [0, 0, 0, 2, 0, 0, 5, 3, 8],\n    [4, 0, 2, 0, 0, 0, 0, 1, 3],\n    [9, 0, 0, 3, 0, 4, 0, 8, 7],\n    [6, 0, 8, 0, 7, 0, 2, 5, 0],\n    [3, 0, 0, 0, 0, 5, 0, 2, 0],\n    [0, 0, 5, 0, 3, 7, 0, 9, 0],\n    [0, 1, 7, 0, 0, 0, 3, 4, 0]\n];\n\n\nlet board2 = [\n    [0, 5, 1, 3, 6, 2, 7, 0, 0],\n    [0, 4, 0, 0, 5, 8, 0, 0, 0],\n    [0, 0, 0, 4, 0, 0, 0, 2, 5],\n    [0, 8, 0, 0, 0, 0, 9, 0, 3],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [7, 0, 5, 0, 0, 0, 0, 8, 0],\n    [1, 2, 0, 0, 0, 9, 0, 0, 0],\n    [0, 0, 0, 2, 8, 0, 0, 6, 0],\n    [0, 0, 8, 5, 3, 4, 2, 9, 0]\n];\n\n\nlet board3 = [\n    [0, 2, 0, 0, 0, 4, 3, 0, 0],\n    [9, 0, 0, 0, 2, 0, 0, 0, 8],\n    [0, 0, 0, 6, 0, 9, 0, 5, 0],\n    [0, 0, 0, 0, 0, 0, 0, 0, 1],\n    [0, 7, 2, 5, 0, 3, 6, 8, 0],\n    [6, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 0, 2, 0, 5, 0, 0, 0],\n    [1, 0, 0, 0, 9, 0, 0, 0, 3],\n    [0, 0, 9, 8, 0, 0, 0, 6, 0]\n]\n\nlet board4 = [\n    [0, 2, 0, 0, 0, 4, 3, 0, 0],\n    [0, 0, 0, 0, 2, 0, 0, 0, 0],\n    [0, 0, 0, 6, 0, 0, 0, 5, 0],\n    [1, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 7, 0, 5, 0, 0, 6, 0, 0],\n    [6, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 8, 0, 2, 0, 5, 0, 0, 0],\n    [0, 0, 0, 0, 9, 0, 0, 0, 3],\n    [0, 0, 9, 8, 0, 0, 0, 6, 0]\n]\n*/\n\n//-------------------------------------------For testing purposes--------------------------------------------------\n\n//let solver0 = new SudokuSolver(board0);\n//console.log(\"Solving 0\");\n//console.log(solver0.solve());\n /*\nsolver1 = new SudokuSolver(board1);\nsolver2 = new SudokuSolver(board2);\nsolver3 = new SudokuSolver(board3);\nsolver4 = new SudokuSolver(board4);\n\nconsole.log(\"Solving 1\");\nconsole.log(solver1.solve());\nconsole.log(\"Solving 2\");\nconsole.log(solver2.solve());\nconsole.log(\"Solving 3\");\nconsole.log(solver3.solve());\nconsole.log(\"Solving 4\");\nconsole.log(solver4.solve());\n*/\n\n\n"]},"metadata":{},"sourceType":"module"}